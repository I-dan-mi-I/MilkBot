# for discord
import nextcord
from nextcord.ext import commands
from settings import settings
from nextcord.ext import tasks
from nextcord.utils import get

# for logs
import asyncio
from time import time
from datetime import datetime

# data base
import database.stat as stat
import database.serversettings as serversetting

connected = False
session = None
uri = settings["StatUri"]

# for card
from card.stat import *
import unicodedata

# for multipage embed
from nextcord_paginator import paginator as Paginator

# for cards
from settings import banners  # name of cards
from settings import colors  # name of colors from Pillow


def massive_split(mas):
    masx = []
    l10 = len(mas) // 10
    for i in range(l10 + 1):
        masx.append(mas[i * 10 : (i + 1) * 10])
    return masx


@tasks.loop(seconds=60)  # repeat after every 60 seconds
async def reconnect():
    global session
    global connected

    connected = False
    session = stat.connectToDatabase(uri, session)
    connected = True


class Stats(commands.Cog, name="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"):
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–µ—Ä–≤–µ—Ä–∞"""

    COG_EMOJI = "üìì"

    def __init__(self, bot):
        self.bot = bot
        reconnect.start()

    @commands.command(pass_context=True, brief="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    @commands.guild_only()
    async def —Ä–∞–Ω–≥(self, ctx, *–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å):
        global session
        global connected

        usr = –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å

        # check user input
        if usr == ():
            user = ctx.author
        else:
            usr = usr[0]
            if usr.startswith("<"):
                usr = usr[3:-1]
            try:
                user = await ctx.guild.fetch_member(usr)
                pass
            except:
                await ctx.send("–ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥!")

        # if not connected to database
        if connected != True:
            await asyncio.sleep(1)

        x = stat.getInfo(session, ctx.guild.id, user.id)

        statcard = newstat()

        if user.avatar != None:
            statcard.avatar = user.avatar.url
        else:
            statcard.avatar = f"https://cdn.discordapp.com/embed/avatars/{str(int(user.discriminator)%5)}.png"

        statcard.name = unicodedata.normalize("NFKC", str(user.display_name))

        statcard.color = x.color

        statcard.path = x.background

        statcard.coin = x.coin

        statcard.quote = x.quotex

        if x.allvoicetime == None:
            statcard.voicetime = 0
        else:
            statcard.voicetime = x.allvoicetime

        if x.cookie == None:
            statcard.cookie = 0
        else:
            statcard.cookie = x.cookie

        if x.xp == None:
            statcard.xp = 0
        else:
            statcard.xp = x.xp

        if x.lvl == None:
            statcard.lvl = 0
        else:
            statcard.lvl = x.lvl

        # sending image to discord channel
        await ctx.send(file=await statcard.create())

    @commands.command(brief="–¢–æ–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–µ—Ä–≤–µ—Ä–∞")
    @commands.guild_only()
    async def –ª–∏–¥–µ—Ä—ã(self, ctx):
        global session

        peoples = massive_split(list(stat.getAllInfoSorted(session, ctx.guild.id)))
        s = 0
        embs = []
        for people_list in peoples:
            emb = nextcord.Embed(title=f"–¢–æ–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π | {ctx.guild.name}")
            emb.color = nextcord.Colour.green()
            emb.set_thumbnail(url=ctx.guild.icon.url)

            for idx, items in enumerate(people_list):
                strx = ""
                if items.lvl != None:
                    strx = f"**–£—Ä–æ–≤–µ–Ω—å:** {items.lvl}|"
                else:
                    strx = f"**–£—Ä–æ–≤–µ–Ω—å:** 0|"

                if items.xp != None:
                    strx = strx + f"**–û–ø—ã—Ç:** {items.xp}|"
                else:
                    strx = strx + f"**–û–ø—ã—Ç:** 0|"

                if items.cookie != None:
                    if items.cookie != 0:
                        strx = strx + f":cookie: {items.cookie}|"

                if items.coin != None:
                    if items.coin != 0:
                        strx = strx + f":coin: {items.coin}|"

                if items.allvoicetime != None:
                    if items.allvoicetime != 0:
                        hours = items.allvoicetime // 3600
                        minutes = (items.allvoicetime % 3600) // 60
                        if minutes < 10:
                            minutes = "0" + str(minutes)
                        seconds = (items.allvoicetime % 3600) % 60
                        if seconds < 10:
                            seconds = "0" + str(seconds)

                        strx = strx + f":microphone: {hours}:{minutes}:{seconds}"

                member = get(ctx.guild.members, id=items.uid)
                if member != None:
                    name = get(ctx.guild.members, id=items.uid).display_name
                else:
                    name = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–∫–∏–Ω—É–ª —Å–µ—Ä–≤–µ—Ä"

                emb.add_field(
                    name=f"{s*10 + idx + 1}. {name}",
                    value=strx,
                    inline=False,
                )

            embs.append(emb)
            s += 1

        try:
            await ctx.message.delete()
            pass
        except nextcord.errors.Forbidden:
            pass

        message = await ctx.send(embed=embs[0])

        page = Paginator(
            message,
            embs,
            ctx.author,
            self.bot,
            footerpage=True,
            footerdatetime=False,
            footerboticon=True,
        )
        try:
            await page.start()
        except nextcord.errors.NotFound:
            pass

    @commands.command(pass_context=True, brief="–í—ã–±–æ—Ä —Ü–≤–µ—Ç–∞ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")
    @commands.guild_only()
    async def —Ü–≤–µ—Ç(self, ctx, *—Ü–≤–µ—Ç):
        global session
        global connected
        global colors

        args = —Ü–≤–µ—Ç

        # if user input blank > send colors magazine
        if args == ():
            embs = []

            for i in range(1, 5):
                emb = nextcord.Embed(title=f"–í–∞—Ä–∏–∞–Ω—Ç—ã —Ü–≤–µ—Ç–æ–≤")
                emb.color = nextcord.Colour.random()
                emb.set_image(
                    url=f"https://raw.githubusercontent.com/I-dan-mi-I/images/main/color/{i}.png"
                )
                embs.append(emb)

            try:
                await ctx.message.delete()
                pass
            except nextcord.errors.Forbidden:
                pass

            message = await ctx.send(embed=embs[0], delete_after=60)

            page = Paginator(
                message,
                embs,
                ctx.author,
                self.bot,
                footerpage=True,
                footerdatetime=False,
                footerboticon=True,
            )
            try:
                await page.start()
            except nextcord.errors.NotFound:
                pass

        # else set color to database
        else:
            e = (" ").join(args).lower()
            if e in colors:

                # if not connected to database
                if not connected:
                    await asyncio.sleep(1)

                stat.setColor(session, ctx.guild.id, ctx.author.id, e)
                await ctx.send(f"{ctx.author.mention} —É—Å–ø–µ—à–Ω–æ –∑–∞–º–µ–Ω–µ–Ω–æ!")
            else:
                await ctx.send(
                    f"{ctx.author.mention} —Ç–∞–∫–æ–≥–æ —Ü–≤–µ—Ç–∞ –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞"
                )

    @commands.command(pass_context=True, brief="–í—ã–±–æ—Ä —Ñ–æ–Ω–∞ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")
    @commands.guild_only()
    async def —Ñ–æ–Ω(self, ctx, *—Ñ–æ–Ω):
        global session
        global connected
        global banners

        args = —Ñ–æ–Ω

        # if user input blank > send banners magazine
        if args == ():
            embs = []

            for i in range(1, 15):
                emb = nextcord.Embed(title=f"–í–∞—Ä–∏–∞–Ω—Ç—ã —Ñ–æ–Ω–æ–≤")
                emb.color = nextcord.Colour.random()
                emb.set_image(
                    url=f"https://raw.githubusercontent.com/I-dan-mi-I/images/main/list/{i}.png"
                )
                embs.append(emb)

            try:
                await ctx.message.delete()
                pass
            except nextcord.errors.Forbidden:
                pass

            message = await ctx.send(embed=embs[0], delete_after=60)

            page = Paginator(
                message,
                embs,
                ctx.author,
                self.bot,
                footerpage=True,
                footerdatetime=False,
                footerboticon=True,
            )
            try:
                await page.start()
            except nextcord.errors.NotFound:
                pass

        # else set banner to database
        else:
            e = (" ").join(args).lower()
            if e in banners:
                e = f"https://raw.githubusercontent.com/I-dan-mi-I/images/main/cards/{e}.png"

                # if not connected to database
                if connected != True:
                    await asyncio.sleep(1)

                stat.setBackground(session, ctx.guild.id, ctx.author.id, e)
                await ctx.send(f"{ctx.author.mention} —É—Å–ø–µ—à–Ω–æ –∑–∞–º–µ–Ω–µ–Ω–æ!")
            else:
                await ctx.send(
                    f"{ctx.author.mention} —Ç–∞–∫–æ–≥–æ –±–∞–Ω–Ω–µ—Ä–∞ –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞"
                )

    @commands.command(
        pass_context=True,
        aliases=[f"coin"],
        brief="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–æ–Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
    )
    async def —à–∞—Ä(self, ctx, *–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ):
        global session
        global connected

        args = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ

        if args == ():
            await ctx.send(
                f"{ctx.author.mention}, —É–∫–∞–∂–∏—Ç–µ uid (–æ—Ç–º–µ—Ç—å—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è) –∏ –∫–æ–ª-–≤–æ —à–∞—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –µ–º—É –¥–æ–±–∞–≤–∏—Ç–µ!"
            )
        else:
            usr = args[0]
            if usr.startswith("<"):
                usr = usr[3:-1]

            if connected != True:
                await asyncio.sleep(1)

            try:
                user = await self.bot.fetch_user(usr)
                pass
            except:
                await ctx.send("–ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥ UID!")

            try:
                ball = int(args[1])
                pass
            except:
                await ctx.send("–ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥ —á–∏—Å–ª–∞ —à–∞—Ä–æ–≤!")

            stat.addBalls(session, ctx.guild.id, user.id, ball)
            await ctx.send(f"{ctx.author.mention}, –¥–æ–±–∞–≤–ª–µ–Ω–æ!")

    @commands.command(pass_context=True, brief="–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–∏—Ç–∞—Ç—ã –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")
    @commands.guild_only()
    async def —Ü–∏—Ç–∞—Ç–∞(self, ctx, *—Ü–∏—Ç–∞—Ç–∞):
        global session
        global connected

        args = —Ü–∏—Ç–∞—Ç–∞—ã

        if args == ():
            await ctx.send(
                f"{ctx.author.mention}, –Ω–∞–ø–∏—à–∏—Ç–µ —Ü–∏—Ç–∞—Ç—É –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞: 33 —Å–∏–º–≤–æ–ª–∞, –≤–∫–ª—é—á–∞—è –ø—Ä–æ–±–µ–ª—ã."
            )
        else:
            e = (" ").join(args)
            if len(e) <= 33:
                if not connected:
                    await asyncio.sleep(1)

                stat.setQuote(session, ctx.guild.id, ctx.author.id, e)
                await ctx.send(f"{ctx.author.mention}, —É—Å–ø–µ—à–Ω–æ –∑–∞–º–µ–Ω–µ–Ω–æ!")
            else:
                await ctx.send(
                    f"{ctx.author.mention}, –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞: 33 —Å–∏–º–≤–æ–ª–∞, –≤–∫–ª—é—á–∞—è –ø—Ä–æ–±–µ–ª—ã! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞"
                )


def setup(bot):
    bot.add_cog(Stats(bot))
